
// EncryptImageToolDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "EncryptImageTool.h"
#include "EncryptImageToolDlg.h"
#include "afxdialogex.h"
#include "SelectFolderDlg.h"
#include <afxwin.h>
#include "Tools.h"
#include "EncryptImage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// 用于应用程序“关于”菜单项的 CAboutDlg 对话框

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 对话框数据
	enum { IDD = IDD_ABOUTBOX };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CEncryptImageToolDlg 对话框



CEncryptImageToolDlg::CEncryptImageToolDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(CEncryptImageToolDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CEncryptImageToolDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CEncryptImageToolDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTFILESEL, &CEncryptImageToolDlg::OnBnClickedButfilesel)
	ON_BN_CLICKED(IDC_BUTFILEOUT, &CEncryptImageToolDlg::OnBnClickedButfileout)
	ON_BN_CLICKED(IDC_BUTENSTART, &CEncryptImageToolDlg::OnBnClickedButenstart)
	ON_BN_CLICKED(IDC_BUTTONKEY, &CEncryptImageToolDlg::OnBnClickedButtonReadKey)
	ON_BN_CLICKED(IDC_BUTZIP, &CEncryptImageToolDlg::OnBnClickedButzip)
	ON_EN_KILLFOCUS(IDC_EDITMAXBOX, &CEncryptImageToolDlg::OnEnKillfocusEditmaxbox)
	ON_EN_KILLFOCUS(IDC_EDITMINBOX, &CEncryptImageToolDlg::OnEnKillfocusEditminbox)
	ON_EN_KILLFOCUS(IDC_EDIT, &CEncryptImageToolDlg::OnEnKillfocusEdit)
END_MESSAGE_MAP()


// CEncryptImageToolDlg 消息处理程序

BOOL CEncryptImageToolDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO:  在此添加额外的初始化代码
	m_selFilePath = "";
	m_selFileOutPath = "";
	m_zipFilePath = "";
	m_exePath = Tool::curdir();

	clear(m_key);
	m_vecPngFiles.clear();
	m_vecZipPngFiles.clear();
	m_vecAllFiles.clear();
	GetDlgItem(IDC_BUTENSTART)->EnableWindow(0);

	CheckFilePath();

	m_pMinEdit = (CEdit*)GetDlgItem(IDC_EDITMINBOX);
	m_pMinEdit->SetWindowTextW(_T("65"));
	m_pMinEdit->SetSel(0, 2);

	m_pMaxEdit = (CEdit*)GetDlgItem(IDC_EDITMAXBOX);
	m_pMaxEdit->SetWindowTextW(_T("70"));
	m_pMaxEdit->SetSel(0, 2);


	m_pSelFileEdit = (CEdit*)GetDlgItem(IDC_EDIT);

	std::string logPath = Tool::curdir() + "\\log.txt";
	std::fstream file(logPath, std::ios::out);		// 清空文件



	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CEncryptImageToolDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CEncryptImageToolDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CEncryptImageToolDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}



void CEncryptImageToolDlg::OnBnClickedButfilesel()
{
	// TODO:  选择加密文件
	auto filePath = CSelectFolderDlg::Show();

	GetDlgItem(IDC_SEL_FILETXT)->SetWindowTextW(filePath);
	GetDlgItem(IDC_EDIT)->SetWindowText(filePath);
	
	m_selFilePath = CT2CA(filePath.GetBuffer(0));

	UpdateSelFile();
}


void CEncryptImageToolDlg::OnBnClickedButfileout()
{
	// TODO:  选择加密输出文件
	auto outFile = CSelectFolderDlg::Show();

	GetDlgItem(IDC_FILE_OUT)->SetWindowTextW(outFile);
	m_selFileOutPath = CT2CA(outFile.GetBuffer(0));


	int lastpos = m_selFileOutPath.find_last_of("\\");
	m_zipFilePath = m_selFileOutPath.substr(0, lastpos);

	m_zipFilePath = m_zipFilePath + "\\PNGZipFiles";


	CheckFilePath();
	CopyAllFile();
}


void CEncryptImageToolDlg::OnBnClickedButenstart()
{
	// TODO:  开始加密
	SetBtnState(false); 

	// 
	int count = 0;	// 当前操作文件数量
	int enCount = 0;	// 可加密数量
	int enCounted = 0; // 已经加密数量
	int maxCount = m_vecZipPngFiles.size();// 需要加密数量

	// 进度条
	int proPos = 0;		// 加密进度
	CProgressCtrl* pProg = (CProgressCtrl*)GetDlgItem(IDC_PROGRESS);
	pProg->SetRange(0, 100);
	pProg->SetPos(0);

	// 加密详细情况列表
	std::string fileState = "";
	CListBox *List;
	List = (CListBox*)GetDlgItem(IDC_LISTCONTROL);
	List->ResetContent();
	if ( m_vecZipPngFiles.empty() )
	{
		Tool::EnToolLog("[error] 无加密文件");
		return;
	}
	
	Tool::EnToolLog("========加密输出====================");
	Tool::EnToolLog("========加密输出 : " + m_selFileOutPath);


	// 开始加密文件
	for (auto &filename : m_vecZipPngFiles)
	{
		Tool::EnToolLog("[encryFile] 待加密文件： " + filename);
		fileState = "";
		int state = CEncryptImage::EncryptPNG(filename, m_key, m_zipFilePath, m_selFileOutPath);

		fileState += filename;
		if ( state == 0)
		{
			fileState += "-->已经加密";
			enCounted++;
		}
		else if ( state == 1)
		{
			fileState += "-->加密成功";
			enCount++;
		}
		else{
			fileState += "-->加密失败";
		}
		count++;

		proPos = count * 100 / maxCount;
		pProg->SetPos(proPos);

		List->AddString(CString(fileState.c_str()));

	}

	List->AddString(_T("!!!!!!加密完成!!!!!!"));


	// 提示加密操作情况
	char chBuff[128];
	sprintf_s(chBuff, "一共有%d个文件加密,加密成功文件:%d个，已经加密文件:%d,", maxCount, enCount, enCounted);
	fileState = chBuff;
	List->AddString(CString(fileState.c_str()));

	// 加密完成
	SetBtnState(true);

	// 加密完成恢复状态
	GetDlgItem(IDC_BUTZIP)->EnableWindow(1);
	GetDlgItem(IDC_BUTENSTART)->EnableWindow(0);
}

void CEncryptImageToolDlg::SetBtnState(bool enable)
{
	GetDlgItem(IDC_BUTFILESEL)->EnableWindow(enable);
	GetDlgItem(IDC_BUTFILEOUT)->EnableWindow(enable);
	GetDlgItem(IDC_BUTENSTART)->EnableWindow(enable);
	GetDlgItem(IDC_BUTTONKEY)->EnableWindow(enable);
}

void CEncryptImageToolDlg::ReadImageKey()
{
	// TODO:  读取秘钥
	auto key_path = CSelectFolderDlg::BootOpenDialog();

	std::ifstream infile;
	infile.open(key_path);   //将文件流对象与文件连接起来 
	if (!infile.is_open())   //若失败,则输出错误消息,并终止程序运行 
	{
		std::cout << "==== 秘钥读取失败" << std::endl;
		GetDlgItem(IDC_KEYTEXT)->SetWindowTextW(_T("读取秘钥失败"));
		return;
	}

	char c;
	int count = 0;
	std::string strKey ="秘钥为：";
	while (infile >> c)
	{
		//infile >> c;
		m_key[count] = c;
		strKey += c;
		count++;

	}
	//关闭文件输入流 
	infile.close();

	Tool::EnToolLog(strKey);

	GetDlgItem(IDC_KEYTEXT)->SetWindowTextW(CString(strKey.c_str()));

}

/**
 * 调用成功 返回 0
 * 失败 返回 -1
 */
int CEncryptImageToolDlg::ImageZipPng(const std::string filename, int minQua, int maxQua)
{
	std::string exePath = m_exePath + "\\pngquant.exe";
	std::string cmdStr = m_exePath + "\\pngZip.bat";
	
	Tool::EnToolLog("[zip file]" + filename);

	std::string outFile = filename.substr(m_selFilePath.size(), filename.size());
	outFile = m_zipFilePath + outFile;

	if (Tool::filedir(outFile) == -1)
	{
		Tool::EnToolLog("[zipout not file]" + outFile);
		return -2;
	}

	Tool::EnToolLog("[zipout png]" + outFile);

	// 执行路径
	cmdStr.append(" ");
	cmdStr.append(exePath);

	// 最小品质
	char chBuff[128];
	sprintf_s(chBuff, " %d", minQua);
	cmdStr.append(chBuff);

	// 最大品质
	sprintf_s(chBuff, " %d", maxQua);
	cmdStr.append(chBuff);

	// 待压缩文件名
	cmdStr.append(" ");
	cmdStr.append(filename);

	// 压缩后文件名
	cmdStr.append(" ");
	cmdStr.append(outFile);
	Tool::EnToolLog("[zipCmd]" + cmdStr);

	WinExec(cmdStr.c_str(), SW_HIDE);
 	int state = system(cmdStr.c_str() );
	return state;

}

void CEncryptImageToolDlg::CheckFilePath()
{
	bool bSet = true;
	if (m_selFilePath.empty())
	{
		bSet = false;
	}
	if ( m_selFileOutPath.empty())
	{
		bSet = false;
	}

	if ( m_key.empty())
	{
		bSet = false;
	}

	if ( bSet )
	{
		GetDlgItem(IDC_BUTZIP)->EnableWindow(1);		// 压缩按钮不可点击
	}
	else
	{
		GetDlgItem(IDC_BUTZIP)->EnableWindow(0);		// 压缩按钮不可点击
	}

}

void CEncryptImageToolDlg::CopyAllFile()
{
	Tool::EnToolLog("=== 复制文件到输出目录 ===");
	for (auto &filename : m_vecAllFiles)
	{
		// 取出相对路径
		auto outFile = filename.substr(m_selFilePath.size(), filename.size());
		// 绝对路径
		std::string out_path = m_selFileOutPath + outFile;
		
		if (Tool::filedir(out_path) == -1 )
		{
			Tool::EnToolLog("[error] 创建复制文件夹失败 " + filename);
			continue;
		}

// 		int lastPos = out_path.find_last_of("\\");
// 		if (lastPos != std::string::npos)
// 		{
// 			out_path = out_path.substr(0, lastPos);
// 		}

		Tool::EnToolLog("[copy] 复制文件 " + out_path);
		//lstrcpy(LPWSTR(filename.c_str()), LPCWSTR(out_path.c_str()));
		if (CopyFile(LPCWSTR(filename.c_str()), LPCWSTR(out_path.c_str()), FALSE))
		{
			Tool::EnToolLog("[suc] 复制文件成功 " + filename);
		}
		else{
			int nError = GetLastError();

			Tool::EnToolLog("[error] 复制文件失败 " + filename);
		}
	}

	Tool::EnToolLog("===== 复制完成 =====");

}

void CEncryptImageToolDlg::UpdateSelFile()
{
	m_vecPngFiles.clear();

	auto allFiles = Tool::walk(m_selFilePath);
	for (auto filename : allFiles)
	{
		if (Tool::splitext(filename)[1] == ".png")
		{
			m_vecPngFiles.push_back(filename);
		}
	}

	m_vecAllFiles.clear();
	m_vecAllFiles = Tool::getAllFiles(m_selFilePath);


	CheckFilePath();
}

void CEncryptImageToolDlg::OnBnClickedButtonReadKey()
{
	// TODO:  读取秘钥按钮
	ReadImageKey();
	CheckFilePath();
}


void CEncryptImageToolDlg::OnBnClickedButzip()
{
	// TODO:  压缩PNG文件
	int maxCount = m_vecPngFiles.size();

	CProgressCtrl* pProg = (CProgressCtrl*)GetDlgItem(IDC_PROGRESS);
	pProg->SetRange(0, 100);
	pProg->SetPos(0);

	int zPos = 0;

	// 加密详细情况列表
	std::string zipFile = "";
	CListBox *List;
	List = (CListBox*)GetDlgItem(IDC_LISTCONTROL);
	List->ResetContent();

	std::string eQua = "";
	CString eStr;

	m_pMinEdit->GetWindowTextW(eStr);
	eQua = CT2CA(eStr.GetBuffer(0));
	int minQua = atoi(eQua.c_str());

	m_pMaxEdit->GetWindowTextW(eStr);
	eQua = CT2CA(eStr.GetBuffer(0));
	int maxQua = atoi(eQua.c_str());

	// 如果最小品质比最大品质大，则提高最大品质 +5
	if ( minQua > maxQua)
	{
		maxQua = minQua + 5;
	}

	// 图片品质设定范围检查
	if ( minQua < 0 || minQua > 95 || maxQua < 5 || maxQua > 100)
	{
		MessageBoxA(NULL, LPCSTR("请重新设置压缩图片品质!"), NULL, MB_OK);
		return;
	}

	// 开始压缩图片
	if (m_vecPngFiles.empty())
	{
		List->AddString(_T("======没有文件可压缩======"));
	}
	else
	{
		List->AddString(_T("======开始压缩PNG======"));
	}

	int count = 1;
	for (auto &filename : m_vecPngFiles)
	{
		char buff[256];
		sprintf_s(buff, "压缩 (%d/%d) ", count, maxCount);
		zipFile += buff;

		zipFile += filename;

		int zipState = ImageZipPng(filename, minQua, maxQua);
		
		if ( zipState == 0)
		{
			zipFile += "==> 压缩完成";
		}
		else{
			zipFile += "==> 压缩完成";
		}
		List->AddString(CString(zipFile.c_str()));


		zPos = count / maxCount * 100;
		pProg->SetPos(zPos);

		count++;
	}

	List->AddString(_T("======压缩PNG完成======"));

	GetDlgItem(IDC_BUTZIP)->EnableWindow(0);		// 压缩按钮不可点击
	GetDlgItem(IDC_BUTENSTART)->EnableWindow(1);	// 压缩完成可以加密


	// 读取待加密文件
	m_vecZipPngFiles.clear();
	std::string zipFilePath = m_zipFilePath;
	auto allFiles = Tool::walk(zipFilePath);
	for (auto filename : allFiles)
	{
		if (Tool::splitext(filename)[1] == ".png")
		{
			m_vecZipPngFiles.push_back(filename);
		}
	}
}

void CEncryptImageToolDlg::OnEnKillfocusEditmaxbox()
{
	// TODO:  设定控件edit可输入数字范围  最大品质
	UpdateData(true);

	std::string eQua = "";
	CString eStr;

	m_pMaxEdit->GetWindowTextW(eStr);
	eQua = CT2CA(eStr.GetBuffer(0));
	int maxQua = atoi(eQua.c_str());

	if ( maxQua <5 || maxQua > 100)
	{
		MessageBoxA(NULL, LPCSTR("品质数值超过范围! (5-100)"), NULL, MB_OK);
		UpdateData(false);
	}
	
}


void CEncryptImageToolDlg::OnEnKillfocusEditminbox()
{
	// TODO:  设定控件edit可输入数字范围  最小品质
	UpdateData(true);

	std::string eQua = "";
	CString eStr;

	m_pMinEdit->GetWindowTextW(eStr);
	eQua = CT2CA(eStr.GetBuffer(0));
	int minQua = atoi(eQua.c_str());

	if (minQua < 0 || minQua > 95)
	{
		MessageBoxA(NULL, LPCSTR("品质数值超过范围! (0-95)"), NULL, MB_OK);
		UpdateData(false);
	}

}


void CEncryptImageToolDlg::OnEnKillfocusEdit()
{
	CString eStr;
	m_pSelFileEdit->GetWindowTextW(eStr);
	std::string outFiles = CT2CA( eStr.GetBuffer(0) );
	m_selFileOutPath = outFiles;

	UpdateSelFile();

}
